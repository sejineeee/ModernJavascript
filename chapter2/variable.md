# 변수

메모리에 저장된 데이터에 접근하기 위해서 메모리셀 주소를 통해 직접 접근하는 것은 불가능하다. 그렇기 때문에 변수를 사용해서 접근하면, 메모리 주소로 변환되어 실행되어 메모리 주소에 접근할 수 있다. 

- 변수 :  할당할 값을 저장하기 위해서 확보한 메모리 공간 또는 메모리 공간을 식별하기 위해 붙인 이름
  - 코어 자바스크립트 책에서는 변수를 테이터를 담을 수 있는 그릇이나 공간이라고 했다.

- 식별자 : 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름
  - 식별자는 값이 아니라 메모리 주소를 기억함
  - 변수, 함수, 클래스 등 메모리 상에 존재하는 값을 식별할 수 있는 이름
  ```javascript
  let a = 'apple' // a는 식별자

  function sayHello() {
    return 'hello'
  } // sayHello는 식별자
  ```

## 변수 선언
var, let, const 키워드를 이용하여 변수를 선언한다. let과 const 키워드는 ES6(2015)에서 추가가 되었다.
(var 키워드는 현재 사용을 지양하고 있다)

```javascript
var name; // 변수 선언
```

javascript 엔진은 변수 선언을 2단계에 거쳐 수행
1. 선언 : 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알림
2. 초기화 : 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화 (초기화 단계를 거치지 않는다면 쓰레기 값이 나올 수 있음)

var 키워드를 사용한 변수 선언은 선언 단계와 초기화 단계가 동시에 진행된다.

### 호이스팅
런타임 이전 단계인 소스코드의 평가 과정에서 모든 선언문을 소스코드에서 찾아서 먼저 실행한다. 런타임 이전에 실행되어 최상단으로 끌어 올려진 것처럼 동작한다.

```javascript
console.log(a); // undefined

var a;
```

```javascript
sayHi() // 'say Hi~'

function sayHi() {
  return 'say Hi~' 
}
```

할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.

### 할당
할당은 런타임에 실행된다. `var`와 `let` 키워드는 재할당이 가능하다. 값을 재할당할 경우, 기존에 있던 메모리 공간을 지우고 값을 새로 저장하는 것이 아닌, 새로운 메모리 공간을 확보하여 저장한다.

기존에 있던 메모리 공간을 아무도 사용하고 있지 않을 경우, 가비지 콜렉터에 의해 메모리에서 자동 해제된다. (해제되는 시점은 예측 못함)

### 식별자 네이밍 규칙
- 식별자는 특수 문자를 제외한 문자, 숫자, 언더스코어, $를 포함할 수 있다.
- 특수 문자는 가급적 사용하지 않는다. 단, 상수의 이름에서 단어를 구분하기 위한 용도와 Private 지시자 표시를 위해 언더스코어를 사용
```
ex)
단어 구분 : RESTAURANT_DETAIL 
Private 표시 : _secret
```
- 식별자는 숫자로 시작하는 것이 불가능하다.
- 예약어는 식별자로 사용 불가능하다.
  - await, break, catch, case, const, new ... 등

#### 네이밍 컨벤션
- camelCase : 일반적으로 변수나 함수에 사용
- snake_case
- PascalCase : 생성자 함수, 클래스의 이름, 모듈에 사용
- 헝가리언 케이스 : v0.5.4 이전에 작성된 코드는 헝가리언 표기법 사용으로 기존 코드의 유지보수를 위해 통일성이 필요한 경우 사용할 수 있으나 그 외에는 사용하지 않음
```javascript
var strFistName // type + idnetifier
var $elem = document.getElementById('userId');
```


식별자 네이밍 규칙에 대해서는 책에도 이해가 쉽게 적혀있었지만, 더 자세하게 알려준 레포를 참고하여 작성하였다.

[참고주소](https://github.com/naver/yobi/blob/master/docs/ko/technical/javascript-naming-convention.md)

